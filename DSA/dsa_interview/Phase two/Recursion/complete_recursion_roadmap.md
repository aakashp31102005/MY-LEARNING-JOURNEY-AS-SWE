# üöÄ **COMPLETE RECURSION & BACKTRACKING MASTERY ROADMAP**
**(FAANG Interview Ready - Every Pattern Covered)**

## **üìä STAGE 1: Recursion Foundations (Week 1)**
*Build recursion mechanics & stack understanding*

### **Mathematical Recursion:**
1. **Factorial** - Basic recursion
2. **Fibonacci Number** - LC 509
3. **Pow(x, n)** - LC 50 
4. **Climbing Stairs** - LC 70 (recursive approach)
5. **GCD/LCM using Euclid's algorithm**
6. **Sum of digits recursively**
7. **Reverse Integer** - LC 7 (recursive)

### **Basic Array/String Recursion:**
8. **Reverse String** - LC 344 (recursive)
9. **Binary Search** - LC 704 (recursive)
10. **Check if array is sorted**
11. **Find Max/Min in array recursively**
12. **Valid Palindrome** - LC 125 (recursive)
13. **Count number of ways to reach n**

---

## **üìä STAGE 2: Linear Recursion & Subsequences (Week 2)**
*Master single-path and choice-based recursion*

### **Array Recursion:**
14. **Reverse array recursively**
15. **Sum of array elements**
16. **Search in array**
17. **Count occurrences of element**

### **Subsequence Patterns:**
18. **Generate all subsequences of string**
19. **Subsets** - LC 78 ‚≠ê
20. **Subsets II** - LC 90 ‚≠ê
21. **Subset Sum Problem (Decision)**
22. **Subset Sum Problem (Count ways)**
23. **Target Sum** - LC 494
24. **Partition Equal Subset Sum** - LC 416 (recursive)

### **String Recursion:**
25. **Print all subsequences of string**
26. **Decode Ways** - LC 91 ‚≠ê
27. **Word Break** - LC 139 (recursive)

---
###  **Linked List Recursion (under core recursion)**

* Reverse a Linked List (recursive) ‚Äì LC 206
* Merge Two Sorted Lists (recursive) ‚Äì LC 21
* Flatten a Multilevel Doubly Linked List ‚Äì LC 430 (recursive approach)
---

## **üìä STAGE 3: Permutations & Combinations (Week 3)**

### 4. **Partition Family**

Problems where we **split an array/string/set into parts** and recurse on the remainder.

* **Palindrome Partitioning** ‚Äì LC 131
* **Partition to K Equal Sum Subsets** ‚Äì LC 698
* **String/Array Segmentation**

    * **Word Break** ‚Äì LC 139
    * **Decode Ways** ‚Äì LC 91

---

### **Permutation Patterns:**
28. **Permutations** - LC 46 ‚≠ê‚≠ê
29. **Permutations II** - LC 47 ‚≠ê‚≠ê
30. **Next Permutation** - LC 31 (recursive understanding)
31. **String Permutations with duplicates**
32. **Permutation in String** - LC 567 (backtrack approach)

### **Combination Patterns:**
33. **Combinations** - LC 77 ‚≠ê‚≠ê
34. **Combination Sum** - LC 39 ‚≠ê‚≠ê
35. **Combination Sum II** - LC 40 ‚≠ê‚≠ê
36. **Combination Sum III** - LC 216 ‚≠ê
37. **Factor Combinations** - LC 254 (Premium)
---
###  **Subset / Permutation Variants**
* Generate Unique Binary Search Trees ‚Äì LC 95 (Catalan recursion)
* Different Binary Search Trees II ‚Äì LC 96
* Generate All Combinations of Well-Formed Brackets with Constraints (generalized n types)
---

## **üìä STAGE 4: String & Expression Backtracking (Week 4)**
*Advanced string manipulation*

### **Parentheses & Brackets:**
38. **Generate Parentheses** - LC 22 ‚≠ê‚≠ê
39. **Remove Invalid Parentheses** - LC 301 ‚≠ê‚≠ê‚≠ê
40. **Valid Parentheses variations**
41. **Different Ways to Add Parentheses** - LC 241 ‚≠ê

### **String Generation:**
42. **Letter Combinations of Phone Number** - LC 17 ‚≠ê‚≠ê
43. **Palindrome Partitioning** - LC 131 ‚≠ê‚≠ê
44. **Restore IP Addresses** - LC 93 ‚≠ê
45. **Generate Abbreviations** - LC 320 (Premium)

### **Advanced String Patterns:**
46. **Wildcard Matching** - LC 44 (recursive) ‚≠ê‚≠ê
47. **Regular Expression Matching** - LC 10 (recursive) ‚≠ê‚≠ê
48. **Interleaving String** - LC 97 (recursive)

---

## **üìä STAGE 5: Grid & Matrix Recursion (Week 5)**
*2D traversal mastery*

### **Path Finding:**
49. **Unique Paths** - LC 62 (recursive)
50. **Unique Paths II** - LC 63 (recursive)
51. **Unique Paths III** - LC 980 ‚≠ê‚≠ê
52. **Count paths in grid (all directions)**
53. **Rat in Maze (single path)**
54. **Rat in Maze (all paths)**

### **Grid Backtracking:**
55. **Word Search** - LC 79 ‚≠ê‚≠ê
56. **Word Search II** - LC 212 ‚≠ê‚≠ê‚≠ê
57. **Number of Islands** - LC 200 (recursive DFS)
58. **Max Area of Island** - LC 695 (recursive)
59. **Surrounded Regions** - LC 130 (recursive)

### **Classic Board Problems:**
60. **N-Queens** - LC 51 ‚≠ê‚≠ê‚≠ê
61. **N-Queens II** - LC 52 ‚≠ê‚≠ê
62. **Sudoku Solver** - LC 37 ‚≠ê‚≠ê‚≠ê
63. **Valid Sudoku** - LC 36 (validation logic)

---

## **üìä STAGE 6: Divide & Conquer Mastery (Week 6)**
*Critical FAANG pattern*

### **Sorting Algorithms:**
64. **Merge Sort** (complete implementation) ‚≠ê‚≠ê
65. **Quick Sort** (complete implementation) ‚≠ê‚≠ê
66. **Kth Largest Element** - LC 215 (QuickSelect) ‚≠ê

### **Array D&C Problems:**
67. **Maximum Subarray** - LC 53 (D&C approach)
68. **Majority Element** - LC 169 (D&C)
69. **Search in Rotated Sorted Array** - LC 33 (D&C)
70. **Find Peak Element** - LC 162 (D&C)
71. **Count Inversions in Array**

### **Expression & Math D&C:**
72. **Different Ways to Add Parentheses** - LC 241
73. **Expression Add Operators** - LC 282 ‚≠ê‚≠ê‚≠ê
74. **Basic Calculator** - LC 224 (recursive)
75. **Evaluate Expression** (custom problems)

---

## **üìä STAGE 7: Advanced Backtracking Patterns (Week 7)**
*FAANG interview favorites*

### **Partition Problems:**
76. **Partition to K Equal Sum Subsets** - LC 698 ‚≠ê‚≠ê
77. **Palindrome Partitioning II** - LC 132 (recursive)
78. **Partition Labels** - LC 763 (understanding)

### **Game Theory & Decision:**
79. **Predict the Winner** - LC 486 ‚≠ê
80. **Stone Game** - LC 877 ‚≠ê
81. **Stone Game II** - LC 1140 ‚≠ê‚≠ê
82. **Nim Game** - LC 292 (concept)
83. **Can I Win** - LC 464 ‚≠ê

### **Advanced Combinatorics:**
84. **Beautiful Arrangement** - LC 526 ‚≠ê
85. **Construct Binary Tree from Preorder** - LC 105
86. **Serialize and Deserialize Binary Tree** - LC 297
87. **Count Numbers with Unique Digits** - LC 357

---

## **üìä STAGE 8: Mathematical & Classic Recursion (Week 8)**
*Famous CS problems*

### **Classic Mathematical:**
88. **Tower of Hanoi** ‚≠ê‚≠ê (Classic!)
89. **Josephus Problem** ‚≠ê (Famous!)
90. **Pascal's Triangle** - LC 118 (recursive)
91. **Catalan Number problems**
92. **Generate Gray Code** - LC 89
93. **Functional recursion tricks ‚Üí tail recursion, mutual recursion**
### **Bit Manipulation Recursion:**
93. **Subsets using bits** - LC 78 (bit approach)
94. **Gray Code** - LC 89 ‚≠ê
95. **Find the Difference** - LC 389 (recursive)

### **Dynamic Programming (Recursive Base):**
96. **House Robber** - LC 198 (recursive + memo)
97. **House Robber II** - LC 213 (recursive)
98. **Best Time to Buy Stock** - LC 121 (recursive understanding)
99. **Coin Change** - LC 322 (recursive + memo)
100. **Longest Common Subsequence** - LC 1143 (recursive)

---

## **üéØ ADVANCED MASTERY CHALLENGES (Week 9)**
*Final boss problems*

### **Ultra Advanced:**
101. **Regular Expression Matching** - LC 10 (complete mastery)
102. **Wildcard Matching** - LC 44 (complete mastery)
103. **Edit Distance** - LC 72 (recursive approach)
104. **Distinct Subsequences** - LC 115 (recursive)
105. **Scramble String** - LC 87 ‚≠ê‚≠ê‚≠ê

---

## **üöÄ CRITICAL PATTERNS & TEMPLATES:**

### **1. Basic Recursion Template:**
```python
def solve(n):
    # Base case
    if n <= 0:
        return base_value
    
    # Recursive case
    return solve(n-1) + additional_work
```

### **2. Choice-based Recursion:**
```python
def solve(arr, index):
    # Base case
    if index >= len(arr):
        return []
    
    # Choice 1: Include current element
    include = [arr[index]] + solve(arr, index + 1)
    
    # Choice 2: Exclude current element  
    exclude = solve(arr, index + 1)
    
    return include + exclude  # or make decision
```

### **3. Backtracking Template:**
```python
def backtrack(path, remaining, result):
    # Base case - found solution
    if is_valid_solution(path):
        result.append(path[:])  # Make copy
        return
    
    # Try each possible choice
    for i, choice in enumerate(remaining):
        if is_valid_choice(choice, path):
            # Make choice
            path.append(choice)
            
            # Recurse with remaining choices
            backtrack(path, remaining[i+1:], result)
            
            # Undo choice (backtrack)
            path.pop()
```

### **4. Divide & Conquer Template:**
```python
def divide_conquer(arr, left, right):
    # Base case
    if left >= right:
        return base_result
    
    # Divide
    mid = (left + right) // 2
    left_result = divide_conquer(arr, left, mid)
    right_result = divide_conquer(arr, mid + 1, right)
    
    # Conquer - combine results
    return merge_results(left_result, right_result)
```

### **5. Grid Backtracking Template:**
```python
def grid_backtrack(grid, row, col, path):
    # Base cases
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):
        return False
    if grid[row][col] == obstacle:
        return False
    
    # Mark as visited
    temp = grid[row][col]
    grid[row][col] = visited_marker
    path.append((row, col))
    
    # Try all 4 directions
    found = (grid_backtrack(grid, row+1, col, path) or
             grid_backtrack(grid, row-1, col, path) or
             grid_backtrack(grid, row, col+1, path) or
             grid_backtrack(grid, row, col-1, path))
    
    # Backtrack
    if not found:
        path.pop()
    grid[row][col] = temp
    
    return found
```

---

## **üìà PRACTICE SCHEDULE:**

### **Week-wise Breakdown:**
- **Week 1:** 4-5 problems/day (Foundations)
- **Week 2:** 4-5 problems/day (Linear recursion)  
- **Week 3:** 5-6 problems/day (Permutations/Combinations)
- **Week 4:** 4-5 problems/day (String backtracking)
- **Week 5:** 4-5 problems/day (Grid problems)
- **Week 6:** 4-5 problems/day (Divide & Conquer)
- **Week 7:** 3-4 problems/day (Advanced patterns)
- **Week 8:** 3-4 problems/day (Mathematical classics)
- **Week 9:** 2-3 problems/day (Final challenges)

### **Daily Study Method:**
1. **Solve without looking** (20-30 mins max)
2. **Draw recursion tree** for understanding
3. **Implement 2-3 approaches** if possible
4. **Calculate time/space complexity**
5. **Code clean solution** with comments
6. **Review similar problems** on LeetCode

---

## **üéØ SUCCESS CHECKPOINTS:**

### **After Week 3:**
‚úÖ Can solve any permutation problem in < 20 minutes  
‚úÖ Understand backtracking template by heart  
‚úÖ Can identify "choice-based" problems instantly  

### **After Week 6:**
‚úÖ Can implement Merge Sort & Quick Sort from scratch  
‚úÖ Master divide & conquer pattern recognition  
‚úÖ Solve grid traversal problems confidently  

### **After Week 9:**
‚úÖ Solve 95% of LeetCode recursion problems  
‚úÖ Handle any FAANG recursion interview question  
‚úÖ Optimize recursive solutions with memoization  
‚úÖ Explain recursion concepts to others clearly  

---

## **üèÜ PATTERN COVERAGE COMPLETE:**

- ‚úÖ **Mathematical Recursion** (7 problems)
- ‚úÖ **Linear & Array Recursion** (13 problems) 
- ‚úÖ **Subsequence Generation** (10 problems)
- ‚úÖ **Permutation Patterns** (10 problems)
- ‚úÖ **Combination Patterns** (8 problems)
- ‚úÖ **String & Expression Backtracking** (12 problems)
- ‚úÖ **Grid & Matrix Traversal** (15 problems)
- ‚úÖ **Divide & Conquer Mastery** (12 problems)
- ‚úÖ **Advanced Backtracking** (12 problems)
- ‚úÖ **Game Theory & Decision Problems** (8 problems)
- ‚úÖ **Mathematical & Classic Problems** (13 problems)
- ‚úÖ **Ultra Advanced Challenges** (5 problems)

**Total: 105 Problems** with **complete LeetCode coverage** and **every single recursion pattern** used in FAANG interviews!

---

## **üéñÔ∏è BONUS TIPS FOR SUCCESS:**

1. **Master the recursion stack visualization**
2. **Always draw the recursion tree first**
3. **Practice problems multiple times until pattern recognition**
4. **Focus on base cases - they're crucial**
5. **Learn to optimize with memoization**
6. **Understand when NOT to use recursion**

**Complete this roadmap and you'll be recursion interview ready! üöÄ**