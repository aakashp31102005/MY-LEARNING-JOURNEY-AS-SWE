# üåê **CORRECTED ULTIMATE GRAPH MASTERY ROADMAP**
**(Complete MAANG Interview Coverage - All Graph Types & Patterns)**

## **üìç STAGE 1: Graph Fundamentals (Week 1)**
*Build core graph understanding - foundation for everything*

### **Graph Representations:**
1. **Graph Representation** - Adjacency List vs Matrix vs Edge List
2. **Build Graph from Input** (edges, prerequisites, etc.)
3. **Directed vs Undirected Graph** concepts
4. **Weighted vs Unweighted Graph** concepts

### **Basic Traversals (Must Master):**
5. **DFS - Recursive Implementation**
6. **DFS - Iterative Implementation** (using stack)
7. **BFS - Queue Implementation** 
8. **Print All Paths between Two Nodes**
9. **Count Connected Components** - Basic version

### **Entry-Level Problems:**
10. **Find if Path Exists in Graph** - LC 1971
11. **Clone Graph** - LC 133 ‚≠ê
12. **Flood Fill** - LC 733

---

## **üìç STAGE 2: Connected Components & Basic Patterns (Week 2)**
*Master connectivity concepts*

### **Connected Components:**
13. **Number of Connected Components in Undirected Graph** - LC 323
14. **Number of Islands** - LC 200 ‚≠ê
15. **Max Area of Island** - LC 695
16. **Number of Provinces** - LC 547
17. **Count Sub Islands** - LC 1905

### **Grid as Graph (FAANG Favorites):**
18. **Surrounded Regions** - LC 130 ‚≠ê
19. **Number of Enclaves** - LC 1020
20. **Pacific Atlantic Water Flow** - LC 417 ‚≠ê
21. **Word Search** - LC 79 (DFS backtracking)

---

## **üìç STAGE 3: Cycle Detection (Week 3)**
*Critical for many advanced patterns*

### **Cycle Detection in Undirected Graphs:**
22. **Detect Cycle in Undirected Graph** - DFS approach
23. **Detect Cycle using Union-Find**
24. **Redundant Connection** - LC 684 ‚≠ê

### **Cycle Detection in Directed Graphs:**
25. **Detect Cycle in Directed Graph** - DFS with recursion stack
26. **Course Schedule** - LC 207 ‚≠ê
27. **Course Schedule II** - LC 210 ‚≠ê
28. **Find Eventual Safe States** - LC 802

---

## **üìç STAGE 4: Topological Sorting (Week 4)**
*Essential for DAG problems*

### **Topological Sort Algorithms:**
29. **Topological Sort using DFS**
30. **Topological Sort using Kahn's Algorithm** (BFS)
31. **All Possible Recipes from Given Supplies** - LC 2115
32. **Alien Dictionary** - LC 269 ‚≠ê‚≠ê

### **Dependency Problems:**
33. **Parallel Courses** - LC 1136
34. **Minimum Height Trees** - LC 310
35. **Longest Increasing Path in Matrix** - LC 329 ‚≠ê *(Moved here - Topological Sort + Memoization)*

---

## **üìç STAGE 5: Union-Find (Disjoint Set Union) (Week 5)**
*Connectivity queries & dynamic graphs*

### **Union-Find Fundamentals:**
36. **Union-Find Implementation** - with path compression & union by rank
37. **Number of Connected Components** - LC 323 (Union-Find version)
38. **Graph Valid Tree** - LC 261 ‚≠ê *(Added - Classic Union-Find)*

### **Union-Find Applications:**
39. **Accounts Merge** - LC 721 ‚≠ê
40. **Most Stones Removed with Same Row/Column** - LC 947
41. **Satisfiability of Equality Equations** - LC 990
42. **Evaluate Division** - LC 399 ‚≠ê (weighted Union-Find)
43. **Redundant Connection II** - LC 685
44. **Number of Operations to Make Network Connected** - LC 1319 ‚≠ê *(Added)*

---

## **üìç STAGE 6: Shortest Path Algorithms (Week 6)**
*Core algorithms for weighted & unweighted graphs*

### **Unweighted Shortest Path (BFS):**
45. **Shortest Path in Binary Matrix** - LC 1091
46. **Open the Lock** - LC 752
47. **Word Ladder** - LC 127 ‚≠ê
48. **Word Ladder II** - LC 126 ‚≠ê‚≠ê *(Added - BFS + Backtracking)*
49. **Minimum Genetic Mutation** - LC 433

### **Weighted Shortest Path (Dijkstra):**
50. **Network Delay Time** - LC 743 (Dijkstra) ‚≠ê
51. **Path with Maximum Probability** - LC 1514
52. **Cheapest Flights Within K Stops** - LC 787 ‚≠ê
53. **Minimum Cost to Make at Least One Valid Path** - LC 1368

### **Negative Weights (Bellman-Ford):** *(Moved from Stage 14)*
54. **Bellman-Ford Algorithm Implementation**
55. **Detect Negative Cycle using Bellman-Ford**
56. **Cheapest Flights with Bellman-Ford approach**

---

## **üìç STAGE 7: Advanced Shortest Path & All-Pairs (Week 7)**
*Advanced shortest path techniques*

### **Advanced BFS Variants:**
57. **01-BFS** (0-1 weighted graphs using deque)
58. **Multi-source BFS** - Rotting Oranges - LC 994 ‚≠ê
59. **Bi-directional BFS** - Word Ladder optimization
60. **As Far from Land as Possible** - LC 1162

### **All-Pairs Shortest Path:** *(Moved from Stage 14)*
61. **Floyd-Warshall Algorithm Implementation**
62. **Find the City with Smallest Number of Neighbors** - LC 1334
63. **Shortest Path Visiting All Nodes** - LC 847 ‚≠ê‚≠ê

### **Dijkstra Variations:**
64. **Path with Minimum Effort** - LC 1631 ‚≠ê
65. **Swim in Rising Water** - LC 778

---

## **üìç STAGE 8: Minimum Spanning Tree (Week 8)**
*MST algorithms for optimization problems*

### **MST Algorithms:**
66. **Kruskal's Algorithm** - Union-Find based
67. **Prim's Algorithm** - Heap based
68. **Min Cost to Connect All Points** - LC 1584 ‚≠ê
69. **Connecting Cities with Minimum Cost** - LC 1135

### **MST Applications:**
70. **Optimize Water Distribution in Village** - LC 1168
71. **Find Critical and Pseudo-Critical Edges in MST** - LC 1489 ‚≠ê
72. **Min Cost to Repair Edges** - MST variant

---

## **üìç STAGE 9: Bipartite Graphs & Coloring (Week 9)**
*Graph coloring and partitioning*

### **Bipartite Graph Detection:**
73. **Is Graph Bipartite?** - LC 785 ‚≠ê
74. **Possible Bipartition** - LC 886
75. **Divide Players into Teams** - Bipartite check

### **Graph Coloring:**
76. **Flower Planting with No Adjacent** - LC 1042
77. **Coloring a Border** - LC 1034
78. **Minimum Number of Vertices to Reach All Nodes** - LC 1557

---

## **üìç STAGE 10: Strongly Connected Components (Week 10)**
*Advanced directed graph algorithms*

### **SCC Algorithms:**
79. **Kosaraju's Algorithm** for SCC
80. **Tarjan's Algorithm** for SCC
81. **Critical Connections in Network** - LC 1192 ‚≠ê (Bridges)
82. **Articulation Points in Graph**

### **SCC Applications:**
83. **Mother Vertex** in directed graph
84. **Check if Graph is Strongly Connected**
85. **Number of Strongly Connected Components**

---

## **üìç STAGE 11: Advanced Graph Patterns (Week 11)**
*Complex patterns for senior interviews*

### **Eulerian Path & Circuits:**
86. **Reconstruct Itinerary** - LC 332 ‚≠ê‚≠ê (Hierholzer's algorithm)
87. **Valid Arrangement of Pairs** - LC 2097

### **Advanced Traversal Patterns:**
88. **Minimum Number of Taps to Open** - LC 1326
89. **Frog Position After T Seconds** - LC 1377
90. **Maximum Employees to Be Invited** - LC 2127

---

## **üìç STAGE 12: Dynamic Programming on Graphs (Week 12)**
*DP + Graphs combination*

### **DAG DP:**
91. **Longest Path in DAG**
92. **Number of Ways to Arrive at Destination** - LC 1976
93. **All Paths from Source to Target** - LC 797
94. **Count Unique Paths in DAG**

### **State Space DP:**
95. **Shortest Path with Alternating Colors** - LC 1129
96. **Number of Ways to Stay in Same Place** - LC 1269
97. **Cherry Pickup II** - LC 1463 (Grid DP + BFS)

---

## **üìç STAGE 13: Optional Advanced Topics (Week 13)**
*For expert-level positions only*

### **Maximum Flow (Optional):**
98. **Ford-Fulkerson Algorithm**
99. **Edmonds-Karp Algorithm** 
100. **Maximum Bipartite Matching**

### **Contest-Level (Very Rare):**
101. **Traveling Salesman Problem** - DP + Bitmask
102. **Hamiltonian Path** (NP-hard, backtracking approach)

---

## **üîß CORRECTED TEMPLATES:**

### **Cycle Detection in Directed Graph:**
```python
def has_cycle_directed(graph):
    WHITE, GRAY, BLACK = 0, 1, 2
    color = [WHITE] * len(graph)
    
    def dfs(node):
        if color[node] == GRAY:  # Back edge found
            return True
        if color[node] == BLACK:  # Already processed
            return False
        
        color[node] = GRAY
        for neighbor in graph[node]:
            if dfs(neighbor):
                return True
        color[node] = BLACK
        return False
    
    for node in range(len(graph)):
        if color[node] == WHITE and dfs(node):
            return True
    return False
```

### **Kahn's Algorithm (Topological Sort):**
```python
from collections import deque

def topological_sort_kahns(graph, n):
    in_degree = [0] * n
    for node in range(n):
        for neighbor in graph[node]:
            in_degree[neighbor] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return result if len(result) == n else []
```

### **Bellman-Ford Algorithm:**
```python
def bellman_ford(graph, start, n):
    dist = [float('inf')] * n
    dist[start] = 0
    
    # Relax edges n-1 times
    for _ in range(n - 1):
        for u in range(n):
            if dist[u] != float('inf'):
                for v, weight in graph[u]:
                    if dist[u] + weight < dist[v]:
                        dist[v] = dist[u] + weight
    
    # Check for negative cycles
    for u in range(n):
        if dist[u] != float('inf'):
            for v, weight in graph[u]:
                if dist[u] + weight < dist[v]:
                    return None  # Negative cycle detected
    
    return dist
```

### **Floyd-Warshall Algorithm:**
```python
def floyd_warshall(graph, n):
    # Initialize distance matrix
    dist = [[float('inf')] * n for _ in range(n)]
    
    # Distance from node to itself is 0
    for i in range(n):
        dist[i][i] = 0
    
    # Fill initial distances
    for u in range(n):
        for v, weight in graph[u]:
            dist[u][v] = weight
    
    # Main algorithm
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
```

---

## **üéØ CORRECTED MASTERY CHECKPOINTS:**

### **After Stage 6:** Can solve 80% of graph interview problems
### **After Stage 10:** Can handle all MAANG medium/hard problems  
### **After Stage 12:** Ready for senior-level interviews
### **After Stage 13:** Expert level (optional for most roles)

---

## **üöÄ PRACTICE STRATEGY:**

### **Daily Schedule:**
- **Week 1-4:** 4-5 problems/day (foundations & patterns)
- **Week 5-8:** 3-4 problems/day (core algorithms)
- **Week 9-12:** 2-3 problems/day (advanced patterns)
- **Week 13:** 1-2 problems/day (optional expert level)

---

## **üèÜ FINAL COVERAGE:**
**Total: 102 Problems** (removed incorrect/non-existent ones)

‚úÖ **Basic Graphs** - Representations & Traversals  
‚úÖ **Connectivity** - Components & Islands  
‚úÖ **Cycles** - Detection in directed/undirected  
‚úÖ **Topological Sort** - DAG ordering + DP on DAG  
‚úÖ **Union-Find** - Dynamic connectivity  
‚úÖ **Shortest Paths** - BFS, Dijkstra, Bellman-Ford, Floyd-Warshall  
‚úÖ **MST** - Kruskal & Prim algorithms  
‚úÖ **Bipartite** - Graph coloring & partitioning  
‚úÖ **SCC** - Strongly connected components  
‚úÖ **Advanced Patterns** - Eulerian paths, complex DP  

**This corrected roadmap eliminates mistakes and provides the most efficient path to graph mastery!** üöÄüí™